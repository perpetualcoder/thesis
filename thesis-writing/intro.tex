\section{Introduction}
Garbage collection (GC) is very useful for software development. It helps the developers to avoid explicit deallocation and dangling pointers. There has been constant complaint that the GC reduces the performance of the application. But the recent research shows that there is in fact much benefit in using it and also well accepted ~\cite{Butters2007}. With the advent of multi-core, the processor utilization is of the high concern and application post multi-core era has been focusing on building concurrent applications. Garbage Collections are designed to be concurrent and parallel. The distinction between concurrent and parallel is if the application runs simultaneously with the garbage collection it is termed as concurrent collector while there are more than one collector thread runs during the collection, it is called as parallel collector. There has been lot of focus on concurrent collectors lately. 

In HPC community, applications are mostly written in languages with no or less managed runtime systems. It is just time that all applications that are written for the huge clusters to change to managed runtime systems~\cite{Endo,APPELSGC}. The HPC applications can benefit all the advantages of the garbage collection. Predominantly HPC codes are written for the two kind of the memory architectures. The first being the shared memory systems, where the memory is common for all the processing element. Other being distributed memory system where each processing element has its own share of memory. Bacon et al~\cite{BaconUTGC} described the theory of garbage collection in very lucid way. The proposed hypothesis is based on the Bacon et al ~\cite{BaconUTGC} observation on the different kinds of garbage collector. The two main GC techniques are Mark-Sweep (MS) and reference counting (RC). All the available GC algorithms follows one of these approach to identify garbage. In abstract, MS traces all the live heap objects and then deletes the untraced but allocated heap objects. On the other hand, RC traces all the dead/potential dead objects and then deletes the traced objects. 

The hypothesis of this research is from the above idea. If MS collector can determine the garbage by traversing the live heap objects, then in a huge memory systems with more live objects the collector should perform worse than RC collectors. In reality, MS is most preferred GC than RC. It is constantly proved that RC performs worse than MS. RC implementations have write barriers which require additional instruction to update the reference count of the heap objects on every change in the object graph.
In a highly optimized GC system with huge memory, RC based systems will perform better than MS. This research focuses towards RC based garbage collection. 

A form of tracing collector called Generational Collector has been used in Java Virtual Machine and commercial Java Virtual Machines~\cite{Vengerov,Tene}. Weak generational hypothesis helps the generational collectors to improve the throughput of the application. The inter-generational pointers (Remember Set) and promotions are  additional overheads of the method. In spite of the overheads, generation collectors are considered as high performance collector in most used run-time systems. Generational collectors, being form of tracing collector traces all the live objects of young generation and move the live objects to different section of the same generation. Occasionally, the younger generation objects move to older generation. Whenever the collection happens  in old generation, it is full heap collection. The old generation collections is not frequent. Considering the huge memory systems, the younger collection itself is very difficult to perform since the young collection could mean tracing inter-site references and huge overheads due to occasional promotional and full heap collections. 

The proposed hypothesis mentioned that the objects are traced only when object is potentially garbage.  In the generational garbage collectors, the live objects in the younger generations are traced on the assumption that the young objects die soon. The orchestration of the collection garbage in younger generation among the different sites is an overhead as we see in the Literature Review that most MS based distributed algorithm failed to detect cycle or mostly centralized. So the hypothesis seems to be clear that the method to be proposed based on tracing only potential garbage objects using RC will perform better than other alternatives in distributed memory systems.
