\chapter*{Abstract}
\label{ch:abstract}

Garbage collection is moving from being a utility to a requirement of every modern programming language. 
With multi-core and distributed systems, most programs written recently are heavily multi-threaded and distributed. Distributed and multi-threaded programs are called concurrent programs. Manual memory management is cumbersome and difficult in concurrent programs.  Concurrent programming is characterized by multiple independent processes/threads, communication between processes/threads, and uncertainty in the order of concurrent operations.

The uncertainty in the order of operations makes manual memory management of concurrent programs difficult. 
A popular alternative to garbage collection in concurrent programs is to use smart pointers.
Smart pointers can collect all garbage only if developer identifies cycles being created in the reference graph. 
Smart pointer usage does not guarantee protection from memory leaks unless cycle can be detected as process/thread create them. General garbage collectors, on the other hand, can avoid memory leaks, dangling pointers, and double deletion problems in any programming environment without help from the programmer.

Concurrent programming is used in shared memory and distributed memory systems. State of the art shared memory systems uses a single concurrent garbage collector thread that processes the reference graph. A single concurrent garbage collector does not utilize multiple compute resources. Distributed memory systems have very few complete garbage collection algorithms but use global barriers, centralized and does not scale well. This thesis  focuses on designing garbage collection algorithms for shared memory and distributed memory systems that satisfy the following properties: concurrent, parallel, scalable, localized (decentralized), low pause time, high promptness, no global synchronization, safe, complete, and operates in linear time.

