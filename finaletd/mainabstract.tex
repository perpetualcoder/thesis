\chapter*{Abstract}
\label{ch:abstract}
Garbage collection is moving from being a utility to a requirement of every modern programming language. 
With multi-core and distributed systems, most programs written recently are heavily multi-threaded and distributed. Distributed and multi-threaded programs are called concurrent programs. Manual memory management is cumbersome and difficult in concurrent programs.  Concurrent programming is characterized by: multiple independent processes/threads, communication between processes/threads, and uncertainty in the order of concurrent operations.

The uncertainty in the order of operations makes manual memory management of concurrent programs difficult. Some programming lanugages offer incomplete garbage collection feature for concurrent programming like smart pointers in C++.
%Languages like C++ offer support for memory management using using smart pointers.
Smart pointers can collect all garbage only if developer identifies cycles being created in the object graph. With uncertainty in the order of operations in the concurrent programs, the cycle creation cannot be detected unless the entire object graph can be traversed by the process/thread.
 Smart pointer usage does not guarantee protection from memory leaks unless cycle can be detected as process/thread mutating reference graph.
 % For cyclic object graphs, a concurrent process must identify that it is creating a cycle and must use a special type of smart pointer to close a cyclic. Smart pointers, therefore, require hints from the programmer to avoid memory leaks. 
 General garbage collectors, on the other hand, can avoid memory leaks, dangling pointers, and double deletion problems in any programming environment without help from the programmer. 

Concurrent programming comes in two flavors : shared memory and distributed memory. Shared memory systems help threads to communicate with each other through shared memory. Most shared memory systems contain single garbage collector that runs concurrently. In distributed memory system, multiple systems contain the process that communicates through messages sent across a network. These systems require synchronization barrier among all the garbage collector in each system to solve the problem. Our thesis focuses on designing garbage collection algorithms for each environment that takes advantage of the environment. 

This thesis offers the solution to multi-collector shared memory garbage collection where multiple garbage collectors can work concurrently with an application and among themselves to perform garbage collection. Multi-collector garbage collection in distributed systems requires synchronization among all the garbage collectors. This thesis aims at designing a multi-collector garbage collector that avoid global barrier among all garbage collectors in all active systems. Our garbage collection algorithms are designed to achieve the solution that is localized, highly-scalable and complete.
