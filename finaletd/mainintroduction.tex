\begin{comment}
This chapter provides the background information regarding the problem discussed in the thesis. Section
~\ref{intro:gc} describes the fundamental idea behind necessity of garbage collection. Advanced readers can skip the section ~\ref{intro:gc}. Section ~\ref{intro:motv} discusses the advantages of the garbage collection and problem statement of the thesis. Section ~\ref{intro:contr} describes all the contributions of this thesis to solve the problem mentioned in section ~\ref{intro:motv}. Section ~\ref{intro:do} helps the readers to understand how the thesis is organized.
\end{comment}
\section{Garbage Collection}
\label{intro:gc}

Processor, algorithm (software), and memory are the trio of computation. Memory is organized by the programming languages and developers can control the life of data allocated in the memory. In this thesis, we abstract all data allocated in the memory as object. In general, we define object as any block of memory that saves any information in the memory and be able to point to other piece of memory by address. Most of the programming supports dynamic memory allocation. To organize memory better, programming languages divide available memory into three types. 
\begin {comment}
All programming languages are designed to perform complex computations. Computation contain three main ingredients : Processing unit, algorithm, and memory. Processing unit i.e., processor is the unit which performs arithmetic, and logical operations required. Algorithm dictates sequence of operation to performed on the data to get the desired output. Algorithm implemented in a programming language is usually referred as program and collection of programs are called software. Memory saves the input, intermediate results and final output of the computation. 
In this thesis, we are more concerned with object oriented programming languages and object represent user defined dynamically allocated data. Developers write algorithms in a specific programming language. Programming language organizes the memory consumed by the algorithm. Modern programming languages uses three different memories to organize it.
\end{comment} 
They are stack, static and heap memory. Static memory contains all the global variables used by the program. Stack memory is used to manage static(fixed size) allocation of object whose scope is well defined. Heap memory is used to manage the dynamically allocated objects which usually has infinite scope unless until mentioned by developers. 

Static memory size requirement is computed at the compilation phase and does not contain objects that are unused at point in time. Stack memory is used to manage the function calls and allocation of objects in the function scope. So the size of the stack memory required for the execution cannot be computed at compilation time, but the size of each call frame can be computed. Uncertainty in the size of stack and heap memory is solved by modeling the remaining memory as two sliders for a box. The size of each section is highly customizable. The idea behind the organization is stack memory is filled from lower address of memory and heap memory is filled from the higher address of the memory. When sliders of both memory meets, the program usually crash if additional memory is requested by the memory. 

Stack memory is memory of all objects that are actively in use or will be used in the near future. Heap memory is memory of all objects whose scope is unknown to the program. Developers control the lifetime of the objects in the heap memory and deletes them when it is no longer used. Memory management is the term used to describe heap memory management. Developers write program that creates the objects in the heap memory and deletes them when it is of no use. The developer managed memory is referred as manual memory management. 

 There are three main issues that happens when heap is manually managed. They are dangling pointers, double free bugs and memory leaks. All of the three issues are deadly and harmful. Some of them produce wrong output to the programs, deletes memory that is in use, and also inefficiently organizes the heap memory. Automatic memory avoids all the above mentioned problems. Apart from all the above mentioned problems, it is extremely difficult to manually manage memory for certain class of programs called concurrent programs. This thesis focuses on designing algorithms to provide finest quality automatic memory management to programming languages runtime systems. The process of automatically managing memory is termed as \textbf{Garbage Collection (GC)}.
\begin{comment}
Heap memory helps developer to extend the life of dynamically allocated objects. Some object allocated in the heap might get very long life as long as the life of the program running. So these objects have infinite life if programmer did not delete them after their last use. The unwanted objects in the heap occupies the heap memory and might make application run out of memory and exit. In order to avoid psuedo full heap memory errors, programmers determine the life of the dynamically allocated objects and delete them. The dynamically allocated objects can be accessed only by pointers in the static and stack memory. These pointers are also called as \textbf{roots}.
\end{comment}
\subsection{How GC's work}
The term garbage refers to the objects allocated in the heap that are not used anymore in the programs. All objects allocated in the memory can referenced by their address. An object $x$ is said to hold a reference to object $y$ when $x$ saves the address of $y$ in it and can always read contents of $y$.To use any object allocated in the heap memory, an object in the stack or static memory must be able to read content in the object through the reference saved in the object itself or through chain of references in multiple object chain.
The objects in the stack and static memory that are considered for defining the use of the object are referred as \textbf{roots}.
So when any root object read contents of an object in the heap memory, then the object cannot be used by the program and should be classified as garbage objects. Dead is an alternative adjective used to describe the objects lost its life and will not be used anymore. Garbage collection is process of collecting all dead objects in the heap memory. 

There are two major technique to identify garbage objects.They are tracing and reference counting. Tracing involves marking all the object in the heap that are in use by going through all the chain of references from roots. Once the marking is done, all unmarked object in the heap is considered as garbage and deleted by the garbage collection program. Reference counting approach attaches a counter to each object that counts number of object that hold reference to it. When the counter reaches zero, the object identifies that it is garbage and deletes itself.

\section{Motivation and Objectives}
\label{intro:motv}
Developers are using managed languages and runtime systems for several benefits including no dangling pointers, no double free bugs, no memory leaks, high productivity, and less code to write ~\cite{Butters}.  
\begin{comment}
The main advantage of the garbage collections are 
\begin{enumerate}
	\item Dangling Pointers
	\item Double free bugs
	\item Memory Leaks
\end{enumerate}
\end{comment}
\paragraph{Dangling Pointers:}
	Dangling pointers are those references in
	the object where developer deleted the object a reference points, but still hold the address of the object in another object. So these references are very dangerous in nature as one does not know what the reference points to. If the reference points to some other object, then computation might yeild undesired output or crash because of mismatch in type information of the object. The cost of these errors are very high. If a developer did not realize the dangling pointers are available, then the program crash.
\paragraph{Double free bugs:}
	Double free bugs is an issue that happens when an object allocated in the heap is deleted at some point in time and programmer deletes the object again at the same address. It is very risky and can lead to dangling pointers in some cases. If no new objects are created at the same address, then the delete will crash the program. In other extreme cases where some object is allocated at the same address, it deletes the object and create dangling pointers for all the object that holds reference to deleted object. 
\paragraph{memory leaks:}
	The most important of all is that the object is allocated in the heap and it is not used. The unused object is not deleted and it consumes memory which could be reused for other objects. This inefficient organization of heap can affect the runtime of an application heavily. This affects the memory allocator as there will be less memory available to allocate and program crashes when there is no memory available to allocate memory for more objects.
	
These advantages are very crucial for successful execution of any application. This thesis focuses on concurrent programs and automatic memory management requirement in concurrent programs. 

Concurrent programs is termed used to describe multiple programs running simultaneously to perform some computation. There are two different environment where concurrent programs are used : Shared memory and distributed memory systems. Shared memory systems contain multiple processors / multi-core processors sharing a common memory to execute the threads / processes. Thread communicate using shared memory and may use atomic instructions or traditional lock to execute some critical sections of the program. 
In shared memory environment, concurrent programmers use smart pointers to manually manage memory. Smart pointers are manual reference counting technique implemented by application programming interface. Distributed memory systems contain multiple processors with dedicated memory and processors are separated by some physical distance and connected via network. Distributed memory system multiple process running on each processor and processes communicate by sending messages across network to perform the computation. Both of the environment contain programs that run concurrently and requires some form of communication to perform desired computation. Both of the environment uses automatic memory management features to help developers build applications. 

When concurrent programs are written by developers, the manual memory management is extremely difficult and error-prone. When multiple threads access a common object, the dangling pointers are common scenario due to the incomplete information about ownership. Double free bugs can occur just as frequent as the dangling pointers. Smart pointers are defacto standards to avoid memory management issues in the concurrent programs. These smart pointers does not guarantee complete garbage collection unless until carefully used. The use of cyclic objects in the heap memory requires extreme care in manually managed concurrent program. It is carefully avoided by all programmers usually to make the program memory leak free. The above reasons explain how difficult the automatic memory management in the concurrent programming environment is and necessity for high quality automatic memory management in concurrent programming environments. 

Beyong solving the garbage collection in concurrent programming environment, the main objectives of this thesis are to design garbage collectors for shared and distributed memory system that satisfy the following properties
\begin{enumerate}
	\item Concurrent garbage collectors (Less pause time)
	\item Multi-collector garbage collection
	\item No global synchornization (High Throughput)
	\item Locality based garbage collection
	\item Scalable
	\item Promptness
	\item Safety
	\item Completeness
\end{enumerate}

\paragraph{Concurrent:}
	Concurrent garbage collectors have negligible to zero pause time. As these type of collectors process heap along side application, application does not get locked and waiting for the garbage collector to finish processing.
\paragraph{Multi-collector Garbage :}
	Multi-collector garbage collections are multiple independent garbage collectors that work independently on the heap to identify garabge. These collectors utilize multi-processors systems when there is lot of compute resources being under utilized.
\paragraph{Global Synchronization:}
	When multi-collector garbage collectors are used, conventional solutions require global barrier among all the collectors to communicate and share the information to identify garbage objects and delete them. With no global synchronization, throughput of garbage collectors will be high.
\paragraph{Locality based garbage collection:}
	Detecting garbage is a global predicate. Traditionally, popular methods of garbage collection algorithm involves computing garbage as global predicate. This requires scanning entire heap for better evaluating the predicate. If garbage object can be detected locally based on the a small set of object, then the garbage detection process can be parallelized.
\paragraph{Scalable:}
	With increase in the size of memory, conventional global garbage collection techniques will not scale with synchronization and scanning the entire heap(s). A garbage collection algorithm must be scalable to meet the future demands. Locality based garbage collection with no globally synchronized multi-collector mechanism is the way for scalability.
\paragraph{Promptness:}
	With global garbage collection, the cost of scanning entire heap often is very expensive. It comes with the cost that the garbage will not be collected until the scanning process starts. We require garbage collector that are prompt in collecting garbage as the heap(s) scanning might be expensive in huge distributed systems.
\paragraph{Safety:}
	Safety property is the most crucial part of the problem. Every garbage collector must delete only garbage object. While most garbage collector in literature satisfy this property, there are some that cannot satisfy this property. This thesis requires garbage collector to be safety in the multi-collector environment which is challenging given that there is no global synchronization.
\paragraph{Completeness:}
	Completeness helps garbage collector to claim that it collects all garbage objects in the heap. Reference counting garbage collector is well known for incomplete garbage colletion due to their inability to collect cyclic garbage. This property is challenging as the locality based collectors usually use reference counting. Garbage collector with localized decision making guarantee completeness is necessary to make the collector highly adaptable to enhance the performance of the applications.
\section{Contributions}
\label{intro:contr}
\section{Dissertation Organization}
\label{intro:do}